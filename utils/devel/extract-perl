#!/usr/bin/perl

=description

This script scans various Perl files for translatable strings.

The scanner uses the Perl Pattern Recognizer to find text() or marktext()
translation routines, either in code or comments, because they sometimes
intentionally contain translatable strings.

This script exists because xgettext and xgettext.pl don't allow us to
extract a sub-set of strings from our SQL files.

=cut

use strict;
use warnings;

use PPR;
use utf8;
use Carp qw( croak );
use Getopt::Long;

#TODO: What relevant options to add?
my $pack;
  GetOptions ("pack"  => \$pack)     # pack references
  or die("Error in command line arguments\n");

my %dict;

sub add_entry {
    my ($string, $file, $line) = @_;

    if ( !$line ) {
        croak "No line for $file:$string";
    }
    $dict{$string} = []
        if ! exists $dict{$string};

    push @{$dict{$string}}, "#: $file:$line\n";
}

sub slurp{ local (*ARGV, $/); @ARGV = shift; readline; }

while (<>) {
    chomp;

    my $file = $_;
    my $source = slurp($file);

    # Empty line count array
    my @lines;        # To record line numbers
    my $line = 1;

    my @text = grep {defined}
        $source =~
            m{
               ((?&PerlEndOfLine) (??{ ++$line }))*?     # Count the lines
               (?: (?:[Mm]ark)?[Tt]ext\b                 # Introducer
                   (?&PerlOWS) [\(\s] (?&PerlOWS))       # '(' or ' '
               ((?&PerlString)) (?{ push @lines,$line }) # string and line
               $PPR::GRAMMAR                             # Preload our grammar
             }gmx;
    next if !@text;

    # Deduplicate, standardize and pack line references
    my %text;
    for (@text) {
        my $string = $_;

        # @lines must follow @text
        my $line = shift @lines;

        my $type = $string =~ m/^('|q\b|<<\s*')/  ?  "Q"
                 : $string =~ m/^("|qq\b|<<\s*")/ ? "DQ"
                                                  :  "-";
        # Prevent unwanted interpolations
        if ( $type ne "Q" && $string =~ m( .* ((?&PerlVariable)) .* $PPR::GRAMMAR)x ) {
            croak "$file:$line: Direct variable interpolation not supported; use bracketed ([_1]) syntax to replace $1";
            next;
        }

        # Remove beginning and end delimitors
        # The following doesn't work yet
        #$string = $2
        #    if $string =~ m( .* ((?&PerlString)) .* $PPR::GRAMMAR);
        #warn "string = '$string', 1 = <$1>, 2 = <$2>, 3 = <$3>, 4 = <$4>";
        #TODO: Replace by the above once PPR has added support
        if    ( $string =~ /^(["'])(.*)\1$/s )       { $string = $2 ;} # "string"
        elsif ( $string =~ /^q{1,2}\((.*)\)$/s)      { $string = $1 ;} # q() or qq()
        elsif ( $string =~ /^<<(['"\b])([a-z0-9_])\1;
                             \s*(?:\#[^\n]*)
                             (.*)\n\2$/mxi)          { $string = $3 ;} # heredoc
        else {
            croak "$file:$line: Unsupported string delimiters in <$string>";
            next;
        }
        # Prepare for GetText, using doublequotes
        $string =~ s/\\'/'/g if $type eq "Q";  # No need to escape single quotes

        next if $string =~ m/^[\s\t\n]*$/g; # skip empty/space-only strings

        push @{$text{$string}}, $line;
    }
    if ( $pack ) {
        add_entry($_, $file, join(',',@{$text{$_}}))
            for (keys %text);
    } else {
        for my $k (keys %text) {
            add_entry($k, $file, $_)
                for (@{$text{$k}});
        }
    }
};

foreach my $string (sort keys %dict) {
    foreach my $location (sort @{$dict{$string}}) {
        print $location;
    }
    $string =~ s/\n/\"\n\"/g;
    print "msgid \"$string\"\n";
    print "msgstr \"\"\n\n";
}
