#!/usr/bin/perl

=pod

This script scans various Perl files for translatable strings.

The scanner uses the Perl Pattern Recognizer to find text() or marktext()
translation routines, either in code or comments, because they sometimes
intentionally contain translatable strings.

This script exists because xgettext and xgettext.pl don't allow us to
extract a sub-set of strings from our SQL files.

=cut

use strict;
use warnings;
use utf8;

use PPR;
use Carp qw( croak );

my %dict;

sub add_entry {
    my ($string, $file, $line) = @_;

    if ( !$line ) {
        croak "No line for $file:$string";
    }
    $dict{$string} = []
        if ! exists $dict{$string};

    push @{$dict{$string}}, "#: $file:$line\n";
}

sub slurp{ local (*ARGV, $/); @ARGV = shift; readline; }

while (<>) {
    chomp;
    open SOURCE, "<:encoding(UTF-8)", $_
        or die "Can't open '$_'; error: $!";

    my $state = NUL;
    my $line_no = 1;
    my $file = $_;
    my $source = slurp($file);

    # Empty line count array
    my @lines;        # To record line numbers
    my $line = 1;

    my @text = grep {defined}
        $source =~
            m{
               ((?&PerlEndOfLine) (??{ ++$line }))*?     # Count the lines
               (?: (?:[Mm]ark)?[Tt]ext\b                 # Introducer
                   (?&PerlOWS) [\(\s] (?&PerlOWS))       # '(' or ' '
               ((?&PerlString)) (?{ push @lines,$line }) # string and line
               $PPR::GRAMMAR                             # Preload our grammar
             }gmx;
    next if !@text;

    # Deduplicate and standardize
    my %text;
    for (@text) {
        my $string = $_;

        # @lines must follow @text
        my $line = shift @lines;

        my $type = $string =~ m/^(?&PerlQuotelikeQ)  $PPR::GRAMMAR/x ?  "Q"
                 : $string =~ m/^(?&PerlQuotelikeQQ) $PPR::GRAMMAR/x ? "DQ"
                                                                     :  "-";
        # Prevent unwanted interpolations
        if ( $type ne "Q" && $string =~ m/ ((?&PerlVariable)) $PPR::GRAMMAR/x ) {
            croak "$file:$line: Direct variable interpolation not supported; use bracketed ([_1]) syntax to replace $1";
            next;
        }

        # Remove beginning and end delimiters
        # The following doesn't work yet
        #$string = $2
        #    if $string =~ m( .* ((?&PerlStringUnquoted)) .* $PPR::GRAMMAR);
        #TODO: Replace the 3 next lines by the above once PPR has added support
        if    ( $string =~ /^(["'])(.*)\1$/s )       { $string = $2 ;} # "string"
        elsif ( $string =~ /^q{1,2}\((.*)\)$/s)      { $string = $1 ;} # q() or qq()
        elsif ( $string =~ m/^(?<PerlHeredoc>)
                             \s*(?:\#[^\n]*)\n
                             (.*)\n(?<_heredoc_terminator>)
                             $PPR::GRAMMAR $/mxi)    { $string = $3 ;} # heredoc
        else {
            croak "$file:$line: Unsupported string delimiters in <$string>";
            next;
        }
        # Prepare for GetText, using doublequotes
        $string =~ s/\\'/'/g if $type eq "Q";  # No need to escape single quotes

        next if $string =~ m/^[\s\t\n]*$/g; # skip empty/space-only strings

        push @{$text{$string}}, $line;
    }
    for my $k (keys %text) {
        add_entry($k, $file, $_)
            for (@{$text{$k}});
    }
};

foreach my $string (sort keys %dict) {
    foreach my $location (sort @{$dict{$string}}) {
        print $location;
    }
    $string =~ s/\n/\"\n\"/g;
    print "msgid \"$string\"\n";
    print "msgstr \"\"\n\n";
}
